// Print all nodes that are K-nodes/edges-Away from a given node;
#include<iostream>
#include<stack>
#include<queue>
using namespace std; 

class node
{
public:
	int data; 
	node* left; 
	node* right; 
	// Constructor
   node() :data(0), left(NULL), right(NULL)
		{}
};

class BinaryTree
{
public: node* root; 
	   BinaryTree() :root(NULL) 
		{}
	  ~BinaryTree()
		{}
	  
	  void Additem(int A[], char B[], int size_A , int size_B , stack<node*> S)
	  {   
		  int k = 0;
		  for (int i = 0; i < size_B; i++)
		  {
			  if (B[i] == 'O')
			  {
				  node* temp = new node; 
				  temp->data = A[k]; 
				  root = temp; 
				  S.push(root); 
				  k++; 
			  }

			  else if (B[i] == 'L')
			  {   
				  node* temp = new node; 
				  temp->data = A[k]; 
				  k++;
				  S.top()->left = temp; 
				  S.push(temp); 
			  }


			  else if (B[i] == 'R')
			  {
				  node* temp = new node;
				  temp->data = A[k];
				  k++;
				  S.top()->right = temp;
				  S.push(temp);
			  }

			  else if (B[i] == 'P')
			  {
				  S.pop(); 
			  }

		  }
			  
	  }
	   
	  void Display(node* r)
	  {  
		  if (r != NULL) {
			  
			  cout << "Node: " << r->data << " -> L :  ";
			  if(r->left!=NULL)
			  {
				  cout << r->left->data << ",\t"; 
			  }
			  else
			  {
				  cout << "NULL,  "; 
			  }
			  if (r->right != NULL)
			  {
				  cout<<"R:" << r->right->data << ";\n";
			  }
			  else
			  {
				  cout << "R: NULL;\n"; 
			  }
			  
			  Display(r->left);
			  Display(r->right);
		  }
		  else
		  {
			  return;
		  }
	  }

	

	  void Klevelprint(node* r, queue<node* >& Q, queue<node*>& Q2 , int k)
	  {
		  node* temp = r;
		  if (temp != NULL)
		  {

			  if (Q.empty())
			  {
				  Q.push(temp);
			  }

			  if (k == 0)
			  {
				  while (!Q.empty())
				  {
					  cout << Q.front()->data << "\t"; 
					  Q.pop();
				  }
			  }
			  else 
			  {
				  while (!Q.empty())
				  {
					  if(Q.front()->left != NULL)
					  Q2.push(Q.front()->left);
					  
					  if (Q.front()->right != NULL)
					  Q2.push(Q.front()->right);

					  Q.pop();
				  }

				  while (!Q2.empty())
				  {
					  Q.push(Q2.front());
					  Q2.pop(); 
				  }
				  k--; 
				  if (!Q.empty())
					  Klevelprint(Q.front(), Q, Q2, k);
			  }

		  }
	  }

	  int Node2Rootpath(node* r, int Ndata , queue<node*>&Q)
	  {
		  node* temp = r;
		  if (temp != NULL) {
			  if (temp->data == Ndata)
			  {
				  cout << temp->data << " -> ";
				  Q.push(temp);
				  return 1;
			  }
			  int flag = Node2Rootpath(temp->left, Ndata,Q);
			  if (flag == 1)
			  {
				  Q.push(temp);
				  cout << temp->data << " -> ";
				  return 1;
			  }
			  flag = Node2Rootpath(temp->right, Ndata,Q);
			  if (flag == 1)
			  {
				  Q.push(temp);
				  cout << temp->data << " -> ";
				  return 1;
			  }
		  }
	  }

	  void K_distance_away(node* r, int data, queue<node*>& Q3 , int k )
	  {
		  queue<node*> Q1, Q2; 
		  Node2Rootpath(r, data, Q3);
		  cout << endl<<k<<" nodes away "<<" from "<< data <<" we have :";
		  Klevelprint(Q3.front(), Q1, Q2, k);

		  // removing 15 from the queue as it has printed nodes above it
		  Q3.pop();
		  k--;
		  while (k >= 0)
		  {
			  int val_counter = 0; 
			  int i = k; 
			  while (i > 0)
			  {
				  Q3.front() = Q3.front()->left;
				  i--;
			  }
			  if (Q3.front() != NULL)
			  {
				  cout << Q3.front()->data<<"\t";
			  }

			  Q3.pop();
			  k--;
		  }

	  }

};


int main()
{    
	int A[] = {   1 ,  2 ,   6 ,  8 , 12 ,     13  ,             9   , 14  ,       15 , 16,   18  , 22 ,            19 , 23 ,                                7  , 10  ,     11  ,             3        }; 
	char B[] = { 'O', 'L' , 'L', 'L','L' ,'P', 'R' , 'P', 'P' ,  'R' , 'L' , 'P' ,'R' , 'L' , 'L' , 'L','P' ,'P' , 'R' , 'R' ,'P','P' , 'P', 'P' ,'P' , 'P', 'R', 'L' , 'P', 'R','P','P' ,'P', 'R' ,'P'};
	BinaryTree T;
	stack<node*> S; 
	int s_A = sizeof(A) / sizeof(A[0]); 
	int s_B = sizeof(B) / sizeof(B[0]); 
	
	T.Additem(A, B, s_A, s_B ,S) ;
	
	T.Display(T.root);
	
	queue<node*> Q,Q2,Q3; 
	
	int k = 3 , node_value = 15 ;
	T.K_distance_away(T.root, node_value , Q3,k);

	return 0;
}
